# 3. 운영체제

## 3.1.1 운영체제의 역할과 구조

### 역할

1. CPU 스케줄링과 프로세스 관리
2. 메모리 관리
3. 디스크 파일 관리
4. I/O 디바이스 관리

### 구조
<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/f9abd69a-747b-495b-b474-728f37f6709b" alt="운영체제 구조" width='300px' />
<details><summary>용어</summary><div markdown='1'>
  <br/>
  
    - GUI : 사용자가 전자장치와 상호 작용할 수 있도록 하는 사용자 인터페이스의 한 형태
    - 드라이버 : 하드웨어를 제어하기 위한 소프트 웨어
    - CUI : 그래픽이 아닌 명령어로 처리하는 인터페이스
  </div>
</details>

<br/>

#### 시스템콜

- 운영체제가 커널에 접근하기 위한 인터페이스
- 유저 프로그램이 운영체제의 서비스를 받기 위해 커널 함수를 호출할 때 사용한다.
<details><summary>용어</summary><div markdown="1">
  <br/>

    - I/O 요청 : 입출력 함수, 데이터베이스, 네트워크, 파일 접근 등에 관한 일
    - 트랩(Trap):소프트웨어에 의해 발생하는 인터럽트를 트랩이라 한다.
    - 인터럽트(Interrupt):이벤트 발생을 CPU에게 알리는 것, 하드웨어와 소프트웨어에 의해 발생할 수 있다.
    - 유저 모드 : 유저가 접근할 수 있는 영역을 제한적으로 두며 컴퓨터 자원에 함부로 침범하지 못하는 모드
    - 커널 모드 : 모든 컴퓨터 자원에 접근할 수 있는 모드
    - 커널 : 운영체제의 핵심 부분. 시스템콜 인터페이스를 제공하며 보안, 메모리, 프로세스, 파일 시스템, I/O 디바이스, I/O 요청 관리 등 운영체제의 중추적인 역할을 한다.
</div>
</details>
<br/>

> 유저 프로그램이  I/O 요청으로 트랩을 발동하면 올바른 I/O 요청인지 확인 후 유저 모드가 시스템콜을 통해 커널 모드로 변환되어 실행된다.
  

#### modebit
- 시스템콜이 작동될 때 modebit을 참고하여 유저 모드와 커널 모드를 구분한다.
- modebit의 0은 커널 모드, 1은 유저 모드라고 설정된다.

## 3.1.2 컴퓨터의 요소
- CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이루어져 있다.

### CPU (Central Processing Unit)
- 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치를 말한다.
- 인터럽트에 의해 단순히 메모리에 존재하는 명령어를 해석해서 실행한다.

#### 제어장치 (Control Unit)
- 프로세스 조작을 지시한다.
- 입출력장치 간 통신을 제어하고 명령어들을 일고 해석하며 데이터 처리를 위한 순서를 결정한다.

#### 레지스터
- CPU 안에 있는 임시기억장치
- CPU는 자체적으로 데이터를 저장할 방법이 없어 레지스터를 거쳐 데이터를 전달한다.

#### 산술놀리연산장치 (Arithmetic Logic Unit)
- 덧셈, 뺄셈 같은 두 숫자의 산술 연산과 배타적 논리합, 논리곱 같은 논리 연산을 계산하는 디지털 회로


<img width="566" alt="cpu 연산 처리" src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/f3b9c62e-da7d-4622-b3dd-02aa923bf722">

> CPU 연산 처리
>  1. 제어장치가 메모리, 레지스터에 계산할 값을 로드한다. 
>  2. 제어장치가 레지스터에 있는 값을 계산하라고 산술논리연산장치에 명령한다.
>  3. 제어장치가 계산된 값을 다시 레지스터에서 메모리로 저장한다.

#### 인터럽트
- 신호가 들어왔을 때 CPU를 잠깐 정지시키는 것을 말한다.

  - 하드웨어 인터럽트
    - 키보드를 연결한다거나 마우스를 연결하는 일 등의 IO 디바이스에서 발생하는 인터럽트
  - 소프트웨어 인터럽트 (트랩)
    - 프로세스 오류 등으로 프로세스가 스트템콜을 호출할 때 발동한다.

### DMA 컨트롤러
- I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치
- CPU의 부하를 막아주며 CPU의 일을 부담한다.

### 메모리
- 전자회로에서 데이터나 상태, 명령러 등을 기록하는 장치
- RAM(Random Access Memory)을 일걸어 메모리라고도 한다.
- 기억을 담당한다.

### 타이머
- 작업이 끝나는 시간을 정하고 특정 프로그램에 시간 제한을 다는 역할을 한다.

### 디바이스 컨트롤러
- 컴퓨터와 연결되어 있는 IO 디바이스들의 작은 CPU
> 로컬 버퍼 : 각 디바이스에서 데이터를 임시로 저장하기 위한 작은 메모리

## 3.2.1 메모리 계층
<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/90fae4bb-64f3-4241-afc6-5f20afd959f3" alt="메모리 계층"/>

- 레지스터, 캐시, 메모리, 저장장치로 구정되어 있다.
  - 레지스터 : CPU 안에 있는 작은 메모리. 휘발성, 속도 가장 빠름, 기억 용량이 가장 적다.
  - 캐시 : L1, L2 캐시를 지칭한다. 휘발성, 속도 빠름, 기억 용량이 적다. L3 캐시도 있다.
  - 메모리(주기억장치) : RAM
  - 저장장치(보조기억장치) : HDD, SSD

### 캐시
- 데이터를 미리 복사해 놓는 임시 저장소
- 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리

### 캐시히트와 캐시미드
- 캐시히트 : 캐시에서 원하는 데이터를 찾았을 때
- 캐시미스 : 해당 데이터가 캐시에 없어서 메모리로 가서 데이터를 찾아올 때
### 캐시매핑
- 캐시가 히트되기 위해 매핑하는 방법
  - 직접 매핑
  - 연관 매핑
  - 집합 연관 매핑

### 웹 브라우저의 캐시
- 쿠키
  - 만료기한이 있는 키-값 저장소이다.
  - 4KB까지 데이터를 저장할 수 있고 만료기한을 정할 수 있다.
- 로컬 스토리지
  - 만료기한이 없는 키-값 저장소이다.
  - 10MB까지 저장할 수 있으며 웹 브라우저를 닫아도 유지되고 도메인 단위로 저장, 생성된다.
  - HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며 클라이언트에서만 수정 가능하다.
- 세션 스토리지 
  - 만료기한이 없는 키-값 저장소이다.
  - 탭 단위로 생성하며, 탭을 닫을 때 해당 데이터가 삭제된다.
  - 5MB까지 저장 가능하고 HTML5를 지원하지 않는 웹 브라우저에서는 사용할 수 없으며 클라이언트에서만 수정 가능하다.

## 3.2.2 메모리 관리

### 가상 메모리
- 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메로리로 보이게 만드는 것
- 가상 주소와 실제 주소가 매핑되어 있고 프로세스의 주소 정보가 들어 있는 `페이지 테이블`로 관리된다.(속도 향상을 위해 TLB를 쓴다.)
<details>
<summary>용어 정리</summary><div markdown="1">

    - TLB : 메모리와 CPU 사이에 있는 주소 변환을 위한 캐시이다. 페이지 테이블에 있는 리스트를 보관하며 CPU가 페이지 테이블까지 가지 않도록 하여 속도를 향상시킬 수 있는 캐시 계층이다.
    - 가상 주소 : 가상적으로 주어진 주소, 메모리관리장치(MMU)에 의해 실제 주소로 변환된다.
    - 실제 주소 : 실제 메모리 상에 존재하는 주소
    - 페이지 : 가상 메모리를 사용하는 최소 크기 단위
    - 프레임 : 실제 메모리를 사용하는 최소 크기 단위
</div>
</details>
<br/>

- 스와핑
  - 페이지 폴트가 발생했을 때 메모리에서 당장 사용하지 않는 영역을 하드디스크로 옮기고 하드디스크의 일부분을 마치 메모리처럼 불러와 쓰는 것.
- 페이지 폴트
  - 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우에 발생한다.
> 페이지 폴트와 그로 인한 스와핑 순서
> 1. CPU는 물리 메모리를 확인하여 대항 페이지가 없으면 트랩을 발생해서 운영체제에 알린다.
> 2. 운영체제는 CPU의 동작을 잠시 멈춘다.
> 3. 운영체제는 페이지 테이블을 확인하여 가상 메모리에 페이지가 있는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾는다. 물리 메모리에도 없다면 스와핑이 발동한다.
> 4. 비어 있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화한다.
> 5. 중단되었던 CPU를 다시 시작한다.

### 스레싱
<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/a13719f5-3d12-4ed6-8c1e-f0e4bf992ea4" alt='스레싱' />

- 메모리의 페이지 폴트율이 높은 것을 의미하며, 컴퓨터의 심각한 성능 저하를 일으킨다.
> 해결 방법
>  1. 메모리를 늘린다.
>  2. HDD를 SSD로 바꾼다.
>  3. 작업세트 : 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어서 미리 메모리에 로드하느 것
>  4. PFF(Page Fault Frequency) : 페이지 폴트 빈도를 조절하는 방법으로 상한선과 하한선을 만드는 방법

### 메모리 할당

#### 연속 할당

  <details><summary>용어</summary><div>
    <br/>

  <img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/ed956871-9045-4c11-bdf1-79960a4eed5a" alt="내부 단편화 1" width="200px">
  <img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/c73f510e-3664-4312-96ca-d27ba26a9e07" alt="내부 단편화 2" width="200px">

    - 내부 단편화 : 프로그램의 사용 공간을 할당 후 사용되지 않고 남게 되는 현상
<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/6e6ebffe-adb2-4776-8127-75a42af97a2b" alt="외부 단편화" width="">

    - 외부 단편화 : 남아있는 총 메모리 공간이 요청한 메모리 공간보다 크지만, 남아있는 공간이 연속적이지 않아 발생하는 현상
  </div>
  </details>
<br/>

- 연속적으로 공간을 할당하는 것
  - 고정 분할 방식
    - 메모리를 미리 나누어 관리하는 방식
    - 메모리가 미리 나뉘어 있기 때문에 융통성이 없고, 내부 단편화가 발생
  - 가변 분할 방식
    - 매 시점 프로그램의 크기에 맞게 동적으로 메모리를 나눠 사용
    - 내부 단편화는 발생하지 않지만 외부 단편화는 발생 가능
    - 최초적합(first fit), 최적적합(best fit), 최악적합(worst fit)이 있다.


#### 불연속 할당
- 페이징
  - 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 프로세스를 할당한다.
  - 주소 변환이 어렵다.
- 세그멘테이션
  - 페이지 단위가 아닌 의미 단위인 세그먼트로 나누는 방식
  - 코드와 데이터로 나누거나 코드 내의 작은 함수를 세그먼트로 놓고 나눈다.
  - 공유와 보안 측면에서 장점이 있지만 홀의 크기가 균일하지 않다.
- 페이지드 세그멘테이션
  - 프로그램을 의미 단위인 세그먼트로 나눠 공유나 보안 측면에 강점을 두고 임의의 길이가 아닌 동일한 크기의 페이지 단위로 나누는 것


### 페이지 교체 알고리즘
#### 오프라인 알고리즘
- 먼 미래에 참조되는 페이지와 현재 할당하는 페이지를 바꾸는 알고리즘이며 가장 좋은 방법
- 미래를 알 수 없어서 사용할 수 없지만 다른 알고리즘과의 성능 비교에 대한 상한기준을 제공한다.

#### FIFO(First In First Out)
- 가장 먼저 온 페이지를 교체 영역에 가장 먼저 놓는 방법

#### LRU(Least Recently Used)
- 참조가 가장 오래된 페이지를 바꾼다.
- 오래된 것을 파악하기 위해 각 페이지마다 계수기, 스택을 두어야 하는 단점이 있다.

#### NUR(Not Used Recently)
- clock 알고리즘이라고 하며 0과 1을 가진 비트를 둔다.
- 1은 최근에 참조되었고 0 은 참조되지 않았음을 의미한다.
- 시계 방향으로 돌면서 0을 찾고 그 순간 해당 프로 세스를 교체하여 1로 바꾸는 알고리즘

#### LFU
- 가장 참조 횟수가 적은 페이지를 교체한다.

## 3.3 프로세스와 스레드
- 프로세스 : 컴퓨터에서 실행되고 있는 프로그램
- 스레드 : 프로세스 내 작업의 흐름
### 3.3.1 프로세스와 컴파일 과정
<img width="744" alt="컴파일 과정" src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/66f389e6-35e5-45dc-a6c2-e3c5d6eca5c3">

- 전처리
  - 소스 코드의 주석을 제거하고 #include 등 헤더 파일을 병합하여 메크로를 치환한다.
- 컴파일러
  - 오류 처리, 코드 최적화 작업을 하며 어셈블리어로 변환한다.
- 어셈블러
  - 어셈블리어는 목적 코드로 변환된다.
- 링커
  - 프로그램 내에 있는 라이브러리 함수 또른 다른 파일들과 목적 코드를 결합하여 실행 파일을 만든다.
  > 정적 라이브러리 : 프로그램 빌드 시 라이브러리가 제공하는 모든 코드를 실행 파일에 넣는 방식으로 라이브러리를 쓰는 방법.<br/>
  외부 의존도가 낮지만 코드 중복 등 메모리 효율성이 떨어진다.
  
  > 동적 라이브러리 : 프로그램 실행 시 필요할 때만 DLL이라는 함수 정보를 통해 참조하여 라이브러리를 쓰는 방법.<br/>
  메모리 효율성에서의 장점이 있지만 외부 의존도가 높아진다.


### 3.3.2 프로세스의 상태
#### 생성 상태(create)
- 프로세스가 생성된 상태를 의미하며 fork() 또는 exec() 함수를 통해 생성한다. 이때 PCB가 할단된다.
  - fork() : 부모 프로세스의 주소 공간을 그대로 복사하며, 새로운 자식 프로세스를 생성하는 함수
  - exec() : 새롭게 프로세스를 생성하는 함수
#### 대기 상태(ready)
- 메모리 공간이 충분하면 메모리를 할당받고 아니면 아닌 상태로 대기하고 있으며 CPU 스케줄러로부터 CPU 소유권이 넘어오기를 기다리는 상태
#### 대기 중단 상태(ready suspended)
- 메모리 부족으로 일시 중단된 상태
#### 실행 상태(running)
- CPU 소유권과 메모리를 할당받고 인스트럭션을 수행 중인 상태
- CPU burst가 일어났다고도 표현함
#### 중단 상태(blocked)
- 어떤 이벤트가 발생한 이후 기다리며 프로세스가 차단된 상태
- I/O 디바이스에 의한 이터럽트로 이런 현상이 많이 발생한다.
#### 일시 중단 상태(blocked suspended)
- 중단된 상태에서 프로세스가 실행되려고 했지만 메모리 부족으로 일시 중단된 상태
#### 종료 상태(terminated)
- 메모리와 CPU 소유권을 모두 놓고 가는 상태
- 부모 프로세스가 자식 프로세스를 강제시키는 비자발적 종료(abort)로 종료되는 것도 있다. 

### 3.3.3 프로세스의 메모리 구조
`메모리에서 동/정적 영역을 구분하는 것과 변수들을 동/정적 할당하는 것은 별개`

<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/5914af28-60eb-4375-a606-d178c0b21304" alt="프로세스의 메모리 구조" width="200px"/>

<details><summary>용어</summary><div markdown='1'>
  <br/>
  
    - 정적 할당 : 컴파일 단계에서 메모리를 할당하는 것
    - 동적 할당 : 런타임 단계에서 메모리를 할당하는 것
  </div>
</details>

#### 스택
- 지역 변수, 매개변수, 실행되는 함수에 의해 늘어나거나 줄어드는 메모리 영역
#### 힙
- 동적으로 할당되는 변수들을 담는 영역

#### 데이터 영역과 코드 영역
- 데이터 영역
  - BSS segment
  - Data segment
- 코드 영역
  - 프로그램의 코드

### 3.3.4 PCB(Process Control Block)
- 운영체제에서 프로세스에 대한 메타 데이터를 저장한 데이터
- 커널 스택의 가장 앞부분에서 관리된다.
> 메타 데이터 : 데이터에 관한 구조화된 데이터이자 데이터를 설명하는 작은 데이터, 대량의 정보 가운데에서 찾고 있는 정보를 효율적으로 찾아내서 이용하기 위해 일졍한 규칙에 따라 콘텐츠에 대해 부여되는 데이터.

#### PCB의 구조
- 프로세스 스케줄링 상태
- 프로레스 ID
- 프로세스 권한
- 프로그램 카운터
- CPU 레지스터
- CPU 스케줄링 정보
- 계정 정보
- I/O 상태 정보

#### 컨텍스트 스위칭
- PCB를 교환하는 과정
<img src="https://github.com/HongTaeHoon/CS-Study/assets/122140479/e30f4116-911b-46f0-8e68-9f2f0228d903" alt="컨텍스트 스위칭"/>

- 비용 : 캐시미스
  - 컨텍스트 스위칭이 일어날 때 프로세스가 가지고 있는 메모리 주소가 그래도 있으면 잘못된 주소 변환이 생겨 캐시클리어 과정을 겪게 되고 이 때문에 캐시미스가 발생한다.
- 스레드에서의 컨텍스트 스위칭
  - 스레드는 스택 영역을 제외한 모든 메모리를 공유하기 때문에 스레드 컨텍스트 스위칭의 경우 비용도 더 적고 시간도 더 적게 걸린다.

### 3.3.5 멀티프로세싱
- 멀티프로세스를 통해 동시에 두 가지 이상의 일을 수행할 수 있는 것
#### 웹 브라우저
- 브라우저 프로세스 : 주소 표시줄, 북마크 막대, 뒤로 가기 버튼, 앞으로 가기 버튼 등을 담당하며 네트워크 요청이나 파일 접근 같은 권한을 담당
- 렌더러 프로세스 : 웹 사이트가 보이는 부분의 모든 것을 제어한다.
- 플러그인 프로세스 : 웹 사이트에서 사용하는 플러그인을 제어한다.
- GPU 프로세스 : GPU를 이용해서 화면을 그리는 부분을 제어한다.
#### IPC(Inter Process Communication)
- 프로세스끼리 데이터를 주고받고 공유 데이터를 관리하는 메커니즘이다.
  - 공유 메모리
    - 여러 프로세스에 동일한 메모리 블록에 대한 접근 권한이 부여되어 프로세스가 서로 통신할 수 있도록 공유 메모리를 생성해서 통신하는 것
  - 파일
    - 디스크에 저장된 데이터 또는 파일 서버에서 제공한 데이터
    - 이를 기반으로 프로세스 간 통신을 한다.
  - 소켓
    - 동일한 컴퓨터의 다른 프로세스나 네트워크의 다른 컴퓨터로 네트워크 인터페이스를 통해 전송하는 데이터
    - TCP, UDP가 있다.
  - 익명 파이프
    - 프로세스 간에 FIFO 방식으로 읽히는 임시 공간인 파이프를 기반으로 데이터를 주고받으며, 단방향 방식의 읽기 전용, 쓰기 전용 파이프를 만들어서 작동한다.
    - 부모, 자식 프로세스 간에만 사용할 수 있다.
  - 명명 파이프
    - 파이프 서버와 하나 이상의 파이크 클라이언트 간의 통신을 위한 명명된 단방향 또는 양방향 파이프
    - 클라이언트/서버 통신을 위한 별도의 파이프를 제공하며, 여러 파이프를 동시에 사용할 수 있다.
  - 메시지 큐
    - 메시지를 큐(queue) 데이터 구조 형태로 관리하는 것


### 3.3.6 스레드와 멀티스레딩
#### 스레드
- 프로세스의 실행 가능한 가장 작은 단위
- 프로세스는 여러 스레드를 가질 수 있다.
#### 멀티 스레팅
- 프로세스 내 작업을 멀티스레드로 처리하는 기법
- 스레드끼리 자원을 공유하기 때문에 효율성이 높고 동시성에 큰 장점이 있다.
- 한 스레드에 문제가 생기면 다른 스레드에도 영향을 끼친다.
> 동시성 : 독립적인 작업들을 작은 단위로 나누고 동시에 실행되는 것처럼 보여주는 것

### 3.3.7 공유 자원과 임계 영역
#### 공유 자원
- 각 프로세스, 스레드가 함께 접근할 수 있는 모니터, 프린터, 메모리, 파일, 데이터 등의 자원이나 변수
- 경쟁 상태 : 공유 자원을 두 개 이상의 프로세스가 동시에 읽거나 쓰는 상황
  - 접근의 타이밍이나 순서 등이 결괏값에 영향을 줄 수 있다.

#### 임계 영역
- 둘 이상의 프로세스, 스레드가 공유 자원에 접근할 때 순서 등의 이유로 결과가 달라지는 코드 영역
<details><summary>용어</summary><div markdown='1'>
  <br/>
  
    - 상호 배제 : 한 프로세스가 임계 영역에 들어갔을 때 다른 프로세스는 들어갈 수 없다.
    - 한정 대기 : 특정 프로세스가 영원히 임계 영역에 들어가지 못하면 안 된다.
    - 융통성 : 한 프로세스가 다른 프로세스의 일을 방해하면 안 된다.
  </div>
</details>
<br/>

- 뮤텍스
  - 프로세스나 스레드가 공유 자원을 lock()을 통해 잠금 설정하고 사용한 후에는 unlock()을 통해 잠금 해제하는 객체
- 세마포어
  - 일반화된 뮤텍스
  - 간단한 정수 값과 두 가지 함수 wait(), signal()로 공유 자원에 대한 접근을 처리한다.
- 모니터
  - 둘 이상의 스레드나 프로세스가 공유 자원에 안전하게 접근할 수 있도록 공유 자원을 숨기고 해당 접근에 대해 인터페이스만 제공


### 3.3.8 교착 상태
- 두 개 이상의 프로세스들이 서로가 가진 자원을 기다리며 중단된 상태
- 원인
  - 상호 배제
  - 점유 대기
  - 비선점
  - 환형 대기
- 해결 방법
  1. 자원을 할당할 때 애초에 조건이 성립되지 않게 설계한다.
  2. 은행원 알고리즘을 사용한다.
  3. 사이클이 있는지 찾아보고 관련된 프로세스를 한 개씩 지운다.
  4. 사용자가 작업 종료하게 한다. ex) 응답 없음.

## 3.4 CPU 스케줄링 알고리즘
### 3.4.1 비선점형 방식
- 프로세스가 스스로 CPU 소유권을 포기하는 방식
- 강제로 프로세스를 중지하지 않는다.
- 컨텍스트 스위칭으로 인한 부하가 적다.

<br/>

#### FCFS
  - 가장 먼저 온 것을 가장 먼저 처리하는 알고리즘
  - 길게 수행되는 프로세스가 있으면 처리가 늦어진다.
#### SJF
  - 실행 시간이 짧은 프로세스를 가장 먼저 실행하는 알고리즘
  - 실행 시간이 긴 프로세스는 실행되지 않는다.
  - 실제 실행시간을 알 수 없어서 과거의 실행시간을 기준으로 추측해서 실행한다.
#### 우선순위
  - 오래된 작업일수록 우선순위를 높이는 방법
  - SJF의 단점 보완

<br/>

### 3.4.2 선점형 방식
- 사용하고 있는 프로세스를 알고리즘에 의해 중단시켜 버리고 다른 프로세스에 CPU 소유권을 할당하는 방식

<br/>

#### 라운드 로빈
  - 우선순위 스케줄링의 일종으로 각 프로세스는 동일한 할당 시간을 주고 그 시간 안에 끝나지 않으면 다시 준비 큐의 뒤로 가는 알고리즘

#### SRF
- 중간에 더 짧은 작업이 들어오면 수행하던 프로세스를 중지하고 해당 프로세스를 수행하는 알고리즘

#### 다단계 큐
- 우선순위에 따른 준비 큐를 여러 개 사용하고, 큐마다 라운드 로빈이나 FCFS 등 다른 스케줄링 알고리즘을 적용한 것
- 큐 간의 프로세스 이동이 안 되므로 스케줄링 부담이 적지만 유연성이 떨어진다.
