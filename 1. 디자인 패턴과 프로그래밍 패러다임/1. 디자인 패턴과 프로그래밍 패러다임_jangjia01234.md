# 디자인 패턴과 프로그래밍 패러다임

## 📚 라이브러리 vs. 프레임워크

라이브러리와 프레임워크의 차이점은 **제어 흐름의 권한**이 어디에 있는가에 있습니다.

![Alt text](image-1.png)

### 라이브러리

- 공통으로 사용될 수 있는 특정한 기능들을 모듈화한 것
- 소프트웨어를 개발할 때 사용하는 비휘발성 자원의 모임
  - 특정 기능을 모아둔 코드 및 함수의 집합
- 개발자가 전체적인 흐름을 직접 만들며 사용
- Ex. React.js

### 프레임워크

- 기능 구현에 집중할 수 있도록 필요한 기능을 갖추고 있는 것
- 정해진 프로그램의 틀에 맞게 사용자가 필요한 기능을 입력함
- Ex. Vue.js

<br><br>

# 📍 디자인패턴

## 싱글톤 패턴

- 1클래스에 1인스턴스 할당
- Ex. 객체 생성
- 단점
  - TDD 어려움
  - 결합이 강함 -> **의존성 주입**으로 해결

## 팩토리 패턴

- 상-하위 클래스 구분
- 느슨한 결합
- Ex. new Object()

## 전략 패턴

- 정책 패턴이라고도 부름
- 행위를 직접 수정 X -> 전략 내에서 교환
- Ex. 다양한 결제 방식 선택
- 라이브러리: passport (Node.js)

## 옵저버 패턴

- 관찰자가 상태 변화시 변화 알려줌
- Ex. 트위터, MVC 패턴에 이용
- 프록시 객체 구현에 활용 Ex. ref (Java)

## 프록시 패턴과 프록시 서버

- 객체 이전에 흐름 가로채는 것
- Ex. nginx (Node.js), Cloudflare (CDN)
- DDOS 공격 차단
- CORS 에러 프론트엔드에서 이 방식으로 해결 가능

## 이터레이터 패턴

- 다른 구조이더라도 이터레이터로 순회 가능

## 노출모듈 패턴

- 즉시실행함수로 접근제어자(public, private ...) 구현

## MVC 패턴

- View - Controller - Model
- View: UI 요소
- Controller: 메인 로직, 생명주기 관리
- Model: DB, 상수, 변수 등

## MVP 패턴

- View - Presenter - Model

## MVVM 패턴

- View - View Model - Model
- View - View Model: 데이터 바인딩, 커맨드 실행
- Ex. Vue.js

<br><br>

# 🧑‍💻 프로그래밍 패러다임

## 선언형과 함수형 프로그래밍

![Alt text](image-2.png)

### 선언형

- _무엇을 풀어내는가?_ 에 집중하는 패러다임
- _프로그램은 함수로 이루어진 것이다._ 라는 명제가 담겨 있음

### 함수형

- 자바스크립트에서는 함수형 프로그래밍을 선호
- 순수함수 + 고차함수로 이루어짐

<br>

> <details><summary>용어 정리</summary><div markdown="1">
> - 순수함수: 출력이 입력에만 의존하는 것
> <br> - 고차함수: 함수가 함수를 매개변수로 받아 로직을 생성 가능한 것
> <br> ❗️ 고차 함수 사용을 위해서는 해당 언어가 일급 객체여야 함
> <br> ❗️ 일급 객체의 특징
> <br>1️⃣ 변수나 메서드에 함수 할당 가능
> <br>2️⃣ 함수 안에 함수를 매개변수로 담을 수 있음
> <br>3️⃣ 함수가 함수를 반환할 수 있음
> </div></details>

<br><br>

## 객체지향 프로그래밍

### 특징

- 추상화
  - 복잡한 시스템의 핵심 개념 및 기능을 간추려내는 것
  - Ex. 지아: 여자, 24세, 프론트엔드 개발자
- 캡슐화
  - _속성+메서드_ 로 묶고 일부를 외부에 숨기기
- 상속성
  - 상위 클래스의 특성을 하위 클래스에서 이어받기
  - 코드의 재사용, 계층 관계 생성, 유지보수성 면에서 중요
- 다형성
  - 메서드나 클래스가 다양한 방법으로 동작하는 것
  - 대표적으로 오버로딩, 오버라이딩이 있음
    - 오버로딩: 같은 이름의 메서드를 여러 개 두는 것
    - 오버라이딩: 상위 클래스로부터 상속받은 메서드를 하위 클래스가 재정의하는 것

### 원칙

- 단일 책임 원칙 (SRP): 모든 클래스는 각각 하나의 책임만 가져야 한다
- 개방-폐쇄 원칙 (OCP): 유지보수 측면에서 기존 코드를 거의 변경하지 않으면서 쉽게 확장할 수 있어야 한다
- 리스코프 치환 원칙 (LSP): 객체가 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다
  - Ex. 부모 객체에 자식 객체를 넣어도 시스템이 문제 없이 돌아가야 함
- 인터페이스 분리 원칙 (ISP): 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야 한다
- 의존 역전 원칙 (DIP): 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 변화에 영향을 받지 않도록 한다
  - 즉, 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 함

<br>

## 절차형 프로그래밍

- 로직이 수행되어야 할 연속적 계산 과정으로 이루어짐
- 장점: 진행 방식 그대로 코드를 구현하면 되기에 가독성이 높고 실행 속도가 빠름 <br> -> 계산이 많은 과학 연산, 머신러닝 작업 등에 활용
- 단점: 모듈화가 어렵고 유지보수성이 떨어짐
